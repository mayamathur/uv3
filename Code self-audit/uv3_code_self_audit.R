
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
#                                      READ IN DATA 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

root.dir = "~/Dropbox/Personal computer/Independent studies/Uncanny Valley III (UV3)/UV3_OSF"
code.dir = paste( root.dir, "/4_Main_Experiment/Code", sep="" )
data.dir = paste( root.dir, "/4_Main_Experiment/Data", sep="" )
results.dir = paste( root.dir, "/4_Main_Experiment/Results", sep="" )

setwd(code.dir)
source("helper_overall_analysis.R")
source("general_helper_w2.R")

# read in long data
setwd(data.dir)
library(readr)
l = read_csv("long_prepped.csv")

# Wave 2 raw data for checking cursor data parsing
w2 = read.csv("w2_raw_data.csv")
# and subject lists
load( "xl_subject_lists.RData" )
load( "yl_subject_lists.RData" )
load( "tl_subject_lists.RData" )
d = read.csv("wave2_wide_data_prepped.csv")

# read in face data
f2 = read.csv("face_aggregated_simple.csv")

# read in detailed face data
# only used for getting number of validation subjects rating each face
f = read.csv("face_aggregated_detailed.csv")

key = read.csv("autogenerated_stimulus_vs_url_key.csv")


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
#                                  CHECK CURSOR DATA PARSING 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

# manually parse cursor data for the second subject and second face
# manually calculate outcomes and make sure they agree with what we have in saved dataset

l$w1_uID[2]
# confirm unstandardized
mean(l$area, na.rm = TRUE)

id = "61"
site = "Eotvos Lorand University"

# in raw data, keep only data from this one chosen subject
w2.2 = w2[ as.character(w2$w2_id1) == id & w2$w2_site == site, ]

# subset to just this subject
l.2 = l[ as.character(l$w1_id1) == id & l$w1_site == site, ]

d.2 = d[ d$w2_id1 == 61 & d$w2_site == "Eotvos Lorand University", ]



##### Figure out which face this subject saw second #####

# because of randomized ordering
# arbitrarily focus on the second face that the subject saw, which happens
#  to be face.57
face = 2
face.url = strsplit( as.character(w2.2$stimulusOrder), split = "\\|" )[[1]][ face ]
( face.stim.name = key$stim.name[ key$url == face.url ] )

##### Get Splitting Times for This Face #####
( onReadyTime = strsplit( as.character(w2.2$onReadyTime), split = "a" )[[1]][ face ] )
( buttonClickTime = strsplit( as.character(w2.2$buttonClickTime), split = "a" )[[1]][ face ] )
#( latency = strsplit( as.character(w2.2$latency), split = "a" )[[1]][ face ] )

onReadyTime = as.numeric(onReadyTime)
buttonClickTime = as.numeric(buttonClickTime)


##### Get Coordinate Vector for This Face #####

# for all faces
x.all = as.numeric( strsplit( as.character(w2.2$xPos), split = "a" )[[1]] )
y.all = as.numeric( strsplit( as.character(w2.2$yPos), split = "a" )[[1]] )
t.all = as.numeric( strsplit( as.character(w2.2$time), split = "a" )[[1]] )

# coordinate vectors should have same length
library(testthat)
expect_equal( length(x.all), length(y.all) )
expect_equal( length(t.all), length(y.all) )

# keep only coordinate vectors for this face
x.unstd = x.all[ t.all > onReadyTime & t.all < buttonClickTime ]
y.unstd = y.all[ t.all > onReadyTime & t.all < buttonClickTime ]
t.unstd = t.all[ t.all > onReadyTime & t.all < buttonClickTime ]



##### Standardize distances to unit length and starting at coordinates (0,0) #####

n.points = length(x.unstd)

traj.x.length = abs( x.unstd[n.points] - x.unstd[1] )
x = ( x.unstd - x.unstd[1] ) / traj.x.length

traj.y.length = abs( y.unstd[n.points] - y.unstd[1] )
y = abs( ( y.unstd - y.unstd[1] ) / traj.y.length )

# plot the cursor trajectory for this face
plot(x,y)


##### Calculate coordinates of ideal trajectory #####
n.points = length(x)

# how much to increment x and y for each step in ideal
#  trajectory
x.jump = ( x[n.points] - x[1] ) / n.points
y.jump = ( y[n.points] - y[1] ) / n.points

# x.ideal = x[1] + x.jump * (0 : (n.points-1) )
# y.ideal = y[1] + y.jump * (0 : (n.points-1) )

x.ideal = ideal_traj(x, y)

# visualize the ideal and real trajectories
plot(x,y)
points(x.ideal, y, col = "red")
# add start and end points
points(x[1], y[1], col = "blue", pch = 16)
points(x[n.points], y[n.points], pch = 16, col = "green")


##### Reproduce Outcome Measures  #####

# rxnt
t[length(t)] - t[1]
l.2$rxnt[ l.2$stim.name == face.stim.name ]
d.2$rxnt.face.57
# YASSSSSSSS

# x-deviation
l.2$xdev[ l.2$stim.name == face.stim.name ]
max( abs( x - x.ideal ) )
max_x_dev(x,y)
# YASSSSSSSS

# x-flips
change.in.x = diff(x)[ !diff(x) == 0 ]
change.direction = sign( change.in.x )
sum( diff(change.direction) != 0 )
l.2$xflips[ l.2$stim.name == face.stim.name ]
# YASSSSSS

# area
area_vs_ideal( x, y )
l.2$area[ l.2$stim.name == face.stim.name ]
d.2$area.face.57
# YASSSSSS

# speed
print( peak_speed(x, t) )
l.2$speed[ l.2$stim.name == face.stim.name ]
# YASSSSSS




# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
#                                FIT MEDIATION MODEL MANUALLY 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

# pulled this out of the very end of master_analysis.R
#  might need to run that script to get the relevant variables

##### Sanity Check: Fit One Manually #####
f2$med = f2$xflips

# GAM
# (note that package does not handle poly terms, whether coded as poly() or as 
# I(mh^2), etc., so we cannot do that as a sensitivity analysis)
med.mod = gam( med ~ s(mhz) + mean.emot,
               data = f2)

out.small = gam( lik ~ s(mhz) + s(med) + 
                   mean.emot,
                 data = f2) 

out.big = gam( lik ~ s(mhz) + s(med) + 
                 te(mhz, med) +
                 mean.emot,
               data = f2) 


# pick the outcome model with smaller AIC
if ( AIC(out.small) < AIC(out.big) ) {
  out.mod = out.small
  interaction = "no"  # record ultimate decision
} else {
  out.mod = out.big
  interaction = "yes"
}

f2 = as.data.frame(f2)

library(mediation)
set.seed(451)  # as in above
temp = mediate( model.m = med.mod,
                model.y = out.mod,
                boot=TRUE,
                sims = 1000,
                treat="mhz",
                mediator="med",
                treat.value = .5, # 1/2-SD increase in MH score from the mean
                control.value = 0  ) # start at mean MH score since centered

summary(temp)

# prop med
temp$n0
temp$n0.p
temp$n0.ci

temp$d

# matches :) 
